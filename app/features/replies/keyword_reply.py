"""
Layer ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mapping ‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î ‚Üí ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö
- KEYWORD_MAP  : ‡πÄ‡∏Å‡πá‡∏ö mapping ‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏î‡πÅ‡∏ö‡∏ö fix ‡πÄ‡∏ä‡πà‡∏ô "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ" ‚Üí "‡∏ó‡∏±‡∏Å‡∏Ñ‡∏ß‡∏¢‡πÑ‡∏£‡∏ß‡∏∞ ü§î"
- get_reply()  : ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö key ‡πÉ‡∏ô KEYWORD_MAP ‚Üí ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö
- parse_price_command() : ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á "‡∏£‡∏≤‡∏Ñ‡∏≤ XXX" / "price XXX" ‚Üí ‡∏Ñ‡∏∑‡∏ô symbol ‡πÄ‡∏ä‡πà‡∏ô BTCUSDT
- parse_analysis_mock() : ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö 'mock' ‡∏´‡∏£‡∏∑‡∏≠ '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå mock'
- parse_analyze_command() : ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå BTCUSDT 1H'
"""

import re
from typing import Optional

# === Keyword mapping (‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏ï‡πâ‡∏ï‡∏≠‡∏ö‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ) ===
KEYWORD_MAP = {
    "‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô": (
        "üß™ MOCK ALERT\n"
        "‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì: LONG 60% / SHORT 40%\n"
        "‡∏Ñ‡∏π‡πà: BTCUSDT | TF: 1H\n"
        "Entry: 59,000\n"
        "TP1: 59,500 | TP2: 60,200\n"
        "SL: 58,500\n"
        "‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏à‡∏£‡∏¥‡∏á"
    ),
    "mock": (
        "üß™ MOCK ALERT\n"
        "Signal: LONG 60% / SHORT 40%\n"
        "Pair: BTCUSDT | TF: 1H\n"
        "Entry: 59,000 | TP1: 59,500 | TP2: 60,200 | SL: 58,500\n"
        "Note: Test data only."
    ),

    # ===== ‡∏ä‡∏∏‡∏î BTC/‡∏Å‡∏≤‡∏£‡∏û‡∏ô‡∏±‡∏ô‡∏Å‡∏ß‡∏ô‡πÜ =====
    "btc": "BTC ‡∏ô‡∏µ‡πà‡∏°‡∏±‡∏ô‡∏Ñ‡∏≤‡∏™‡∏¥‡πÇ‡∏ô‡∏ä‡∏±‡∏î ‡πÜ üé∞",
    "‡πÄ‡∏õ‡∏¥‡∏î‡∏•‡∏≠‡∏Ñ": "‡πÄ‡∏õ‡∏¥‡∏î‡∏•‡∏≠‡∏Ñ‡∏ó‡∏µ‡πÑ‡∏£ ‡πÄ‡∏à‡πä‡∏á‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ üò≠",
    "‡πÄ‡∏õ‡∏¥‡∏î‡∏ä‡∏≠‡∏ó": "‡πÄ‡∏õ‡∏¥‡∏î‡∏ä‡∏≠‡∏ó‡∏õ‡∏∏‡πä‡∏ö... ‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏ó‡∏∞‡∏•‡∏∏‡∏à‡∏≠ üü¢",
    "sl": "SL ‡πÇ‡∏î‡∏ô‡∏Å‡∏¥‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢... ‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏à‡∏∞‡πÑ‡∏´‡∏• üí¶",
    "tp": "TP ‡πÇ‡∏î‡∏ô‡πÄ‡∏â‡∏µ‡∏¢‡∏î ‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏î‡πâ‡∏á‡∏Å‡∏•‡∏±‡∏ö ‡πÄ‡∏à‡πá‡∏ö‡∏à‡∏µ‡πä‡∏î üò§",
    "‡∏ï‡∏¥‡∏î‡∏î‡∏≠‡∏¢": "‡∏î‡∏≠‡∏¢‡∏™‡∏π‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡∏ô‡∏µ‡πâ ‡∏≠‡∏≠‡∏Å‡∏ã‡∏¥‡πÄ‡∏à‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏°‡πà‡∏û‡∏≠‡πÅ‡∏•‡πâ‡∏ß üèîÔ∏è",
    "‡∏ï‡∏Å‡∏£‡∏ñ": "‡∏£‡∏ñ‡∏Ñ‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏≤‡∏∞‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡πâ‡∏≠‡∏á ü§£",
    "‡∏ï‡∏≤‡∏°‡∏û‡∏µ‡πà": "‡∏≠‡∏¢‡πà‡∏≤‡∏ï‡∏≤‡∏°‡∏û‡∏µ‡πà‡πÄ‡∏•‡∏¢... ‡∏û‡∏µ‡πà‡πÄ‡∏≠‡∏á‡∏Å‡πá‡∏ï‡∏¥‡∏î‡∏î‡∏≠‡∏¢‡∏≠‡∏¢‡∏π‡πà üòÖ",
    "‡πÄ‡∏•‡∏¥‡∏Å‡πÄ‡∏ó‡∏£‡∏î": "‡πÄ‡∏•‡∏¥‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏≠‡∏Å ‡∏°‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ö‡∏±‡∏ô‡πÄ‡∏ó‡∏¥‡∏á üé¢",
    "‡πÄ‡∏à‡πä‡∏á": "‡πÄ‡∏à‡πä‡∏á‡∏≠‡∏µ‡∏Å‡πÅ‡∏•‡πâ‡∏ß... ‡∏ù‡∏≤‡∏Å‡∏ï‡∏±‡∏á‡∏Ñ‡πå‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡∏õ‡∏∞ üí∏",
    "‡πÅ‡∏ï‡∏Å‡∏û‡∏≠‡∏£‡πå‡∏ï": "‡∏û‡∏≠‡∏£‡πå‡∏ï‡πÅ‡∏ï‡∏Å... ‡πÅ‡∏ï‡πà‡πÉ‡∏à‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏Å (‡∏°‡∏±‡πâ‡∏á) üíî",
    "‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô btc": "‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô BTC... ‡∏Ç‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏Ç‡∏≤‡∏¢‡∏Ç‡πâ‡∏≤‡∏ß‡∏°‡∏±‡∏ô‡πÑ‡∏Å‡πà‡∏•‡∏∞ üçó",
    "‡∏ü‡∏•‡∏≠‡∏£‡πå": "‡∏•‡∏á‡πÅ‡∏£‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏Å‡πá‡∏ó‡∏∞‡∏•‡∏∏‡πÉ‡∏ï‡πâ‡∏ñ‡∏∏‡∏ô‡∏ö‡πâ‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß üï≥Ô∏è",
    "‡∏ö‡∏¥‡∏ô": "‡∏ö‡∏¥‡∏ô‡∏ó‡∏µ‡πÑ‡∏£ ‡∏ï‡∏Å‡∏£‡∏ñ‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ ‚úàÔ∏è",
    "‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ô": "‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏Å‡πá‡∏¢‡∏∑‡∏ô‡∏°‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏•‡∏∞‡∏Å‡∏±‡∏ô üëÄ",
    "‡πÅ‡∏ó‡∏á‡∏™‡∏ß‡∏ô": "‡πÅ‡∏ó‡∏á‡∏™‡∏ß‡∏ô‡∏ó‡∏µ‡πÑ‡∏£ ‡πÇ‡∏î‡∏ô‡πÄ‡∏´‡∏¢‡∏µ‡∏¢‡∏ö‡∏à‡∏°‡∏î‡∏¥‡∏ô‡∏ó‡∏∏‡∏Å‡∏ó‡∏µ ü§Ø",
}


def get_reply(text: str) -> Optional[str]:
    """Mapping ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‚Üí ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö (‡∏ï‡∏≤‡∏° KEYWORD_MAP)"""
    if not text:
        return None
    normalized = text.strip().lower()
    for key, reply in KEYWORD_MAP.items():
        if normalized == key.lower():
            return reply
    return None


# === ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏™‡∏£‡∏¥‡∏°: ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡∏≠‡∏£‡∏≤‡∏Ñ‡∏≤ ===
_PRICE_CMD = re.compile(r'^(?:‡∏£‡∏≤‡∏Ñ‡∏≤|price)\s*([A-Za-z]{3,10})(?:/USDT|USDT)?$', re.IGNORECASE)

def parse_price_command(text: str) -> Optional[str]:
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡∏ñ‡πâ‡∏≤ match pattern '‡∏£‡∏≤‡∏Ñ‡∏≤ XXX' ‡∏´‡∏£‡∏∑‡∏≠ 'price XXX'
    ‚Üí return symbol ‡πÄ‡∏õ‡πá‡∏ô XXXUSDT
    ‡πÄ‡∏ä‡πà‡∏ô:
      '‡∏£‡∏≤‡∏Ñ‡∏≤ BTC' ‚Üí 'BTCUSDT'
      'price eth' ‚Üí 'ETHUSDT'
      '‡∏£‡∏≤‡∏Ñ‡∏≤ BTCUSDT' ‚Üí 'BTCUSDT'
    ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà match ‚Üí return None
    """
    if not text:
        return None
    m = _PRICE_CMD.search(text.strip())
    if not m:
        return None
    base = m.group(1).upper()
    return base if base.endswith("USDT") else f"{base}USDT"


# === ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏™‡∏£‡∏¥‡∏°: mock analysis ===
_ANALYZE_MOCK = re.compile(r'^(?:mock|‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå\s*mock)\s*$', re.IGNORECASE)

def parse_analysis_mock(text: str) -> bool:
    """‡∏Ñ‡∏∑‡∏ô True ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏°‡∏û‡πå 'mock' ‡∏´‡∏£‡∏∑‡∏≠ '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå mock'"""
    if not text:
        return False
    return _ANALYZE_MOCK.search(text.strip()) is not None


# === ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏™‡∏£‡∏¥‡∏°: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏à‡∏£‡∏¥‡∏á <symbol> <tf> ===
_TIMEFRAME_MAP = {
    "1h": "1H", "1hr": "1H", "1hrs": "1H",
    "4h": "4H", "4hr": "4H", "4hrs": "4H", "4hours": "4H",
    "1d": "1D", "1day": "1D",
    "1H": "1H", "4H": "4H", "1D": "1D",
}

_ANALYZE_CMD = re.compile(
    r"^(?:‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå|analyze)\s+([A-Za-z0-9:/._-]+)\s+([0-9]+[HhDd][A-Za-z]*)$",
    re.IGNORECASE
)

def parse_analyze_command(text: str) -> Optional[tuple[str, str]]:
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå ‡πÄ‡∏ä‡πà‡∏ô:
      '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå BTCUSDT 1H'
      'analyze BTC 1d'
      '‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå BTC/USDT 4h'
    ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ (symbol, tf) ‡πÇ‡∏î‡∏¢ normalize symbol ‡πÅ‡∏•‡∏∞ tf
    """
    if not text:
        return None
    m = _ANALYZE_CMD.match(text.strip())
    if not m:
        return None

    raw_symbol = m.group(1).upper().replace(":", "").replace("/", "")
    raw_tf = m.group(2)
    tf_key = raw_tf.strip()
    tf_norm = _TIMEFRAME_MAP.get(tf_key, _TIMEFRAME_MAP.get(tf_key.lower()))
    if tf_norm not in ("1H", "4H", "1D"):
        return None

    return raw_symbol, tf_norm
