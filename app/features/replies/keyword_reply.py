"""
Layer à¸ªà¸³à¸«à¸£à¸±à¸š mapping à¸„à¸µà¸¢à¹Œà¹€à¸§à¸´à¸£à¹Œà¸” â†’ à¸„à¸³à¸•à¸­à¸š
- KEYWORD_MAP  : à¹€à¸à¹‡à¸š mapping à¸„à¸µà¸¢à¹Œà¹€à¸§à¸´à¸£à¹Œà¸”à¹à¸šà¸š fix à¹€à¸Šà¹ˆà¸™ "à¸ªà¸§à¸±à¸ªà¸”à¸µ" â†’ "à¸—à¸±à¸à¸„à¸§à¸¢à¹„à¸£à¸§à¸° ðŸ¤”"
- get_reply()  : à¸–à¹‰à¸²à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¸£à¸‡à¸à¸±à¸š key à¹ƒà¸™ KEYWORD_MAP â†’ à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¸­à¸šà¸à¸¥à¸±à¸š
- parse_price_command() : à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸„à¸³à¸ªà¸±à¹ˆà¸‡ "à¸£à¸²à¸„à¸² XXX" / "price XXX" â†’ à¸„à¸·à¸™ symbol à¹€à¸Šà¹ˆà¸™ BTCUSDT
"""

from typing import Optional
import re

# === Keyword mapping (à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹‚à¸•à¹‰à¸•à¸­à¸šà¸—à¸±à¹ˆà¸§à¹„à¸›) ===
KEYWORD_MAP = {
    "à¸—à¸”à¸ªà¸­à¸šà¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™": (
        "ðŸ§ª MOCK ALERT\n"
        "à¸ªà¸±à¸à¸à¸²à¸“: LONG 60% / SHORT 40%\n"
        "à¸„à¸¹à¹ˆ: BTCUSDT | TF: 1H\n"
        "Entry: 59,000\n"
        "TP1: 59,500 | TP2: 60,200\n"
        "SL: 58,500\n"
        "à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸”à¸ªà¸­à¸š à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸ªà¸±à¸à¸à¸²à¸“à¸ˆà¸£à¸´à¸‡"
    ),
    "mock": (
        "ðŸ§ª MOCK ALERT\n"
        "Signal: LONG 60% / SHORT 40%\n"
        "Pair: BTCUSDT | TF: 1H\n"
        "Entry: 59,000 | TP1: 59,500 | TP2: 60,200 | SL: 58,500\n"
        "Note: Test data only."
    ),

    # ===== à¸Šà¸¸à¸” BTC/à¸à¸²à¸£à¸žà¸™à¸±à¸™à¸à¸§à¸™à¹† =====
    "btc": "BTC à¸™à¸µà¹ˆà¸¡à¸±à¸™à¸„à¸²à¸ªà¸´à¹‚à¸™à¸Šà¸±à¸” à¹† ðŸŽ°",
    "à¹€à¸›à¸´à¸”à¸¥à¸­à¸„": "à¹€à¸›à¸´à¸”à¸¥à¸­à¸„à¸—à¸µà¹„à¸£ à¹€à¸ˆà¹Šà¸‡à¸—à¸¸à¸à¸—à¸µ ðŸ˜­",
    "à¹€à¸›à¸´à¸”à¸Šà¸­à¸—": "à¹€à¸›à¸´à¸”à¸Šà¸­à¸—à¸›à¸¸à¹Šà¸š... à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§à¸—à¸°à¸¥à¸¸à¸ˆà¸­ ðŸŸ¢",
    "sl": "SL à¹‚à¸”à¸™à¸à¸´à¸™à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢... à¸™à¹‰à¸³à¸•à¸²à¸ˆà¸°à¹„à¸«à¸¥ ðŸ’¦",
    "tp": "TP à¹‚à¸”à¸™à¹€à¸‰à¸µà¸¢à¸” à¹† à¹à¸¥à¹‰à¸§à¹€à¸”à¹‰à¸‡à¸à¸¥à¸±à¸š à¹€à¸ˆà¹‡à¸šà¸ˆà¸µà¹Šà¸” ðŸ˜¤",
    "à¸•à¸´à¸”à¸”à¸­à¸¢": "à¸”à¸­à¸¢à¸ªà¸¹à¸‡à¸‚à¸™à¸²à¸”à¸™à¸µà¹‰ à¸­à¸­à¸à¸‹à¸´à¹€à¸ˆà¸™à¹€à¸£à¸´à¹ˆà¸¡à¹„à¸¡à¹ˆà¸žà¸­à¹à¸¥à¹‰à¸§ ðŸ”ï¸",
    "à¸•à¸à¸£à¸–": "à¸£à¸–à¸„à¸±à¸™à¸™à¸µà¹‰à¹„à¸¡à¹ˆà¸¡à¸µà¹€à¸šà¸²à¸°à¹€à¸ªà¸£à¸´à¸¡à¹à¸¥à¹‰à¸§à¸™à¹‰à¸­à¸‡ ðŸ¤£",
    "à¸•à¸²à¸¡à¸žà¸µà¹ˆ": "à¸­à¸¢à¹ˆà¸²à¸•à¸²à¸¡à¸žà¸µà¹ˆà¹€à¸¥à¸¢... à¸žà¸µà¹ˆà¹€à¸­à¸‡à¸à¹‡à¸•à¸´à¸”à¸”à¸­à¸¢à¸­à¸¢à¸¹à¹ˆ ðŸ˜…",
    "à¹€à¸¥à¸´à¸à¹€à¸—à¸£à¸”": "à¹€à¸¥à¸´à¸à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸«à¸£à¸­à¸ à¸¡à¸±à¸™à¸„à¸·à¸­à¸„à¸§à¸²à¸¡à¸šà¸±à¸™à¹€à¸—à¸´à¸‡ ðŸŽ¢",
    "à¹€à¸ˆà¹Šà¸‡": "à¹€à¸ˆà¹Šà¸‡à¸­à¸µà¸à¹à¸¥à¹‰à¸§... à¸à¸²à¸à¸•à¸±à¸‡à¸„à¹Œà¹€à¸žà¸´à¹ˆà¸¡à¹„à¸”à¹‰à¸›à¸° ðŸ’¸",
    "à¹à¸•à¸à¸žà¸­à¸£à¹Œà¸•": "à¸žà¸­à¸£à¹Œà¸•à¹à¸•à¸... à¹à¸•à¹ˆà¹ƒà¸ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹à¸•à¸ (à¸¡à¸±à¹‰à¸‡) ðŸ’”",
    "à¸¥à¸²à¸à¹ˆà¸­à¸™ btc": "à¸¥à¸²à¸à¹ˆà¸­à¸™ BTC... à¸‚à¸­à¸à¸¥à¸±à¸šà¹„à¸›à¸‚à¸²à¸¢à¸‚à¹‰à¸²à¸§à¸¡à¸±à¸™à¹„à¸à¹ˆà¸¥à¸° ðŸ—",
    "à¸Ÿà¸¥à¸­à¸£à¹Œ": "à¸¥à¸‡à¹à¸£à¸‡à¸à¸§à¹ˆà¸²à¸™à¸µà¹‰à¸à¹‡à¸—à¸°à¸¥à¸¸à¹ƒà¸•à¹‰à¸–à¸¸à¸™à¸šà¹‰à¸²à¸™à¹à¸¥à¹‰à¸§ ðŸ•³ï¸",
    "à¸šà¸´à¸™": "à¸šà¸´à¸™à¸—à¸µà¹„à¸£ à¸•à¸à¸£à¸–à¸—à¸¸à¸à¸—à¸µ âœˆï¸",
    "à¹€à¸‚à¹‰à¸²à¹„à¸¡à¹ˆà¸—à¸±à¸™": "à¹€à¸‚à¹‰à¸²à¹„à¸¡à¹ˆà¸—à¸±à¸™à¸à¹‡à¸¢à¸·à¸™à¸¡à¸­à¸‡à¸à¸£à¸²à¸Ÿà¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸”à¸µà¸¢à¸§à¸¥à¸°à¸à¸±à¸™ ðŸ‘€",
    "à¹à¸—à¸‡à¸ªà¸§à¸™": "à¹à¸—à¸‡à¸ªà¸§à¸™à¸—à¸µà¹„à¸£ à¹‚à¸”à¸™à¹€à¸«à¸¢à¸µà¸¢à¸šà¸ˆà¸¡à¸”à¸´à¸™à¸—à¸¸à¸à¸—à¸µ ðŸ¤¯",
    
    
}

def get_reply(text: str) -> Optional[str]:
    """
    Mapping à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ â†’ à¸„à¸³à¸•à¸­à¸š (à¸•à¸²à¸¡ KEYWORD_MAP)
    à¸–à¹‰à¸²à¹€à¸ˆà¸­ key à¸•à¸£à¸‡ â†’ return à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¸­à¸š
    à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹€à¸ˆà¸­ â†’ return None
    """
    if not text:
        return None
    normalized = text.strip().lower()
    for key, reply in KEYWORD_MAP.items():
        if normalized == key.lower():
            return reply
    return None

# === à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸ªà¸£à¸´à¸¡: à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸„à¸³à¸ªà¸±à¹ˆà¸‡à¸‚à¸­à¸£à¸²à¸„à¸² ===
_PRICE_CMD = re.compile(r'^(?:à¸£à¸²à¸„à¸²|price)\s*([A-Za-z]{3,10})(?:/USDT|USDT)?$', re.IGNORECASE)

def parse_price_command(text: str) -> Optional[str]:
    """
    à¸•à¸£à¸§à¸ˆà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ à¸–à¹‰à¸² match pattern 'à¸£à¸²à¸„à¸² XXX' à¸«à¸£à¸·à¸­ 'price XXX'
    â†’ return symbol à¹€à¸›à¹‡à¸™ XXXUSDT
    à¹€à¸Šà¹ˆà¸™:
      'à¸£à¸²à¸„à¸² BTC' â†’ 'BTCUSDT'
      'price eth' â†’ 'ETHUSDT'
      'à¸£à¸²à¸„à¸² BTCUSDT' â†’ 'BTCUSDT'
    à¸–à¹‰à¸²à¹„à¸¡à¹ˆ match â†’ return None
    """
    if not text:
        return None
    m = _PRICE_CMD.search(text.strip())
    if not m:
        return None
    base = m.group(1).upper()
    return base if base.endswith("USDT") else f"{base}USDT"
# --- MOCK analysis command parser (à¸§à¸²à¸‡à¹€à¸žà¸´à¹ˆà¸¡à¸—à¹‰à¸²à¸¢à¹„à¸Ÿà¸¥à¹Œ) ---
import re as _re

_ANALYZE_MOCK = _re.compile(r'^(?:mock|à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ\s*mock)\s*$', _re.IGNORECASE)

def parse_analysis_mock(text: str) -> bool:
    """
    à¸„à¸·à¸™ True à¸–à¹‰à¸²à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸žà¸´à¸¡à¸žà¹Œ 'mock' à¸«à¸£à¸·à¸­ 'à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ mock'
    à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸±à¹ˆà¸‡à¹ƒà¸«à¹‰à¸šà¸­à¸—à¸•à¸­à¸šà¸œà¸¥à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸ˆà¸³à¸¥à¸­à¸‡ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¸£à¸²à¸„à¸² API à¸ˆà¸£à¸´à¸‡)
    """
    if not text:
        return False
    return _ANALYZE_MOCK.search(text.strip()) is not None

